<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title> Encrypt Decrypt Python Tool </title>
    <link rel="stylesheet" href="../css/style.css" />
    <!-- Highlight.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/night-owl.min.css" />
</head>
<body>
    <header>
        <h1> Python Tools - Crypto</h1>
        <a href="../index.html">Back to Main Page</a>
    </header>
    <main>
        <section>
            <h2>Tool Overview</h2>
            <p>This tool encryption decryption capability </p>
                
            <h3>Cryptography Tool </h3>
            
                    <pre><code class="language-py">
                        import os
                        import base64
                        
                        from cryptography.hazmat.primitives import hashes, padding
                        from cryptography.hazmat.backends import default_backend
                        from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
                        
                        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
                        from cryptography.hazmat.primitives.ciphers.aead import AESCCM
                        
                        
                        def log_error(_message: str):
                            """
                            Dummy function that does nothing, leaving error.log empty.
                            """
                            pass
                        
                        
                        def create_key_from_password(
                            password: str,
                            salt: bytes,
                            key_size: int = 128,
                            iterations: int = 100_000
                        ) -> bytes:
                            """
                            Derive a key of specified bit length from a given password and salt.
                            Supported key sizes for AES: 128, 192, 256 bits. 
                            We allow 512 bits, but that is not part of AES standard;
                            if 512 is requested, we truncate to 256 bits internally.
                        
                            PBKDF2 with HMAC-SHA256 is used as the KDF.
                        
                            :param password: user password
                            :param salt: random salt
                            :param key_size: 128, 192, 256, or 512 bits
                            :param iterations: PBKDF2 iteration count
                            :return: derived key (bytes)
                            """
                            if key_size not in (128, 192, 256, 512):
                                raise ValueError(f"Unsupported key size: {key_size}. Use 128, 192, 256, or 512.")
                        
                            # PBKDF2 length in bytes
                            length_in_bytes = key_size // 8
                        
                            kdf = PBKDF2HMAC(
                                algorithm=hashes.SHA256(),
                                length=length_in_bytes,
                                salt=salt,
                                iterations=iterations,
                                backend=default_backend()
                            )
                            full_key = kdf.derive(password.encode('utf-8'))
                        
                            # If 512 bits is requested, truncate to 256 bits (32 bytes) for real AES
                            if key_size == 512:
                                return full_key[:32]
                        
                            return full_key
                        
                        
                        def _pkcs7_pad(data: bytes, block_size_bits: int = 128) -> bytes:
                            """
                            Apply PKCS#7 padding to data for block cipher modes (ECB, CBC).
                            AES block size is always 128 bits.
                            """
                            padder = padding.PKCS7(block_size_bits).padder()
                            return padder.update(data) + padder.finalize()
                        
                        
                        def _pkcs7_unpad(data: bytes, block_size_bits: int = 128) -> bytes:
                            """
                            Remove PKCS#7 padding from data for block cipher modes.
                            """
                            unpadder = padding.PKCS7(block_size_bits).unpadder()
                            return unpadder.update(data) + unpadder.finalize()
                        
                        
                        def parse_data_key(file_path: str) -> bytes:
                            """
                            Parse a base64-encoded data key from a file.
                            """
                            try:
                                with open(file_path, 'rb') as f:
                                    encoded_key = f.read().strip()
                                return base64.b64decode(encoded_key)
                            except Exception:
                                # We do not log anything to error.log
                                raise
                        
                        
                        def encrypt_data(key: bytes, plaintext: bytes, aes_mode: str = 'cbc') -> dict:
                            """
                            Encrypt 'plaintext' using AES in 'aes_mode'.
                            Supports: ECB, CBC, CTR, GCM, CCM.
                        
                            Returns a dict with fields:
                              - 'mode': the AES mode
                              - 'ciphertext': base64-encoded ciphertext
                              - 'iv' or 'nonce' (if relevant)
                              - 'tag' if GCM
                              - CCM merges tag into ciphertext (no separate field).
                            """
                            mode = aes_mode.lower()
                        
                            if mode == 'ccm':
                                # CCM uses AESCCM, expects nonce of length 7..13 bytes
                                nonce = os.urandom(13)  # typical
                                aesccm = AESCCM(key, tag_length=16)
                                ciphertext = aesccm.encrypt(nonce, plaintext, None)
                        
                                # AESCCM merges the tag with the ciphertext
                                return {
                                    'mode': mode,
                                    'nonce': base64.b64encode(nonce).decode('utf-8'),
                                    'ciphertext': base64.b64encode(ciphertext).decode('utf-8')
                                }
                        
                            # For block cipher modes, we apply PKCS#7 if needed:
                            if mode in ('ecb', 'cbc'):
                                plaintext = _pkcs7_pad(plaintext)
                        
                            if mode == 'ecb':
                                iv_or_nonce = None
                                cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
                        
                            elif mode == 'cbc':
                                # Must be 16 bytes for AES
                                iv_or_nonce = os.urandom(16)
                                cipher = Cipher(algorithms.AES(key), modes.CBC(iv_or_nonce), backend=default_backend())
                        
                            elif mode == 'ctr':
                                # Must be 16 bytes (128 bits) for CTR in cryptography
                                iv_or_nonce = os.urandom(16)
                                cipher = Cipher(algorithms.AES(key), modes.CTR(iv_or_nonce), backend=default_backend())
                        
                            elif mode == 'gcm':
                                # Typically 12 bytes for GCM
                                iv_or_nonce = os.urandom(12)
                                cipher = Cipher(algorithms.AES(key), modes.GCM(iv_or_nonce), backend=default_backend())
                        
                            else:
                                raise ValueError(f"Unsupported AES mode '{aes_mode}'")
                        
                            encryptor = cipher.encryptor()
                            ciphertext = encryptor.update(plaintext) + encryptor.finalize()
                        
                            result = {
                                'mode': mode,
                                'ciphertext': base64.b64encode(ciphertext).decode('utf-8')
                            }
                        
                            if mode == 'cbc' or mode == 'ctr':
                                result['iv'] = base64.b64encode(iv_or_nonce).decode('utf-8')
                        
                            elif mode == 'gcm':
                                result['nonce'] = base64.b64encode(iv_or_nonce).decode('utf-8')
                                result['tag'] = base64.b64encode(encryptor.tag).decode('utf-8')
                        
                            return result
                        
                        
                        def decrypt_data(key: bytes, data_dict: dict) -> bytes:
                            """
                            Decrypt a ciphertext using the AES mode in data_dict['mode'].
                            Supports: ECB, CBC, CTR, GCM, CCM.
                        
                            For CCM:
                              - 'nonce'
                              - 'ciphertext' (tag merged)
                            For GCM:
                              - 'nonce'
                              - 'tag'
                              - 'ciphertext'
                            For CBC/CTR:
                              - 'iv'
                              - 'ciphertext'
                            For ECB:
                              - 'ciphertext'
                            """
                            mode = data_dict['mode'].lower()
                        
                            if mode == 'ccm':
                                try:
                                    nonce = base64.b64decode(data_dict['nonce'])
                                    ciphertext = base64.b64decode(data_dict['ciphertext'])
                                    aesccm = AESCCM(key, tag_length=16)
                                    plaintext = aesccm.decrypt(nonce, ciphertext, None)
                                    return plaintext
                                except Exception:
                                    # We do not log anything to error.log
                                    raise
                        
                            # For other modes
                            ciphertext = base64.b64decode(data_dict['ciphertext'])
                        
                            if mode == 'gcm':
                                nonce = base64.b64decode(data_dict['nonce'])
                                tag = base64.b64decode(data_dict['tag'])
                                cipher = Cipher(algorithms.AES(key), modes.GCM(nonce, tag), backend=default_backend())
                                decryptor = cipher.decryptor()
                                plaintext = decryptor.update(ciphertext) + decryptor.finalize()
                        
                            elif mode == 'cbc':
                                iv = base64.b64decode(data_dict['iv'])
                                cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
                                decryptor = cipher.decryptor()
                                plaintext = decryptor.update(ciphertext) + decryptor.finalize()
                                # Remove PKCS7 padding
                                plaintext = _pkcs7_unpad(plaintext)
                        
                            elif mode == 'ctr':
                                iv = base64.b64decode(data_dict['iv'])
                                cipher = Cipher(algorithms.AES(key), modes.CTR(iv), backend=default_backend())
                                decryptor = cipher.decryptor()
                                plaintext = decryptor.update(ciphertext) + decryptor.finalize()
                        
                            elif mode == 'ecb':
                                cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
                                decryptor = cipher.decryptor()
                                plaintext = decryptor.update(ciphertext) + decryptor.finalize()
                                # Remove PKCS7 padding
                                plaintext = _pkcs7_unpad(plaintext)
                        
                            else:
                                raise ValueError(f"Unsupported AES mode '{mode}' for decryption.")
                        
                            return plaintext

            </code></pre>

                <h3> Main Py </h3>
                    <pre><code class="language-py"> 
            
                    import argparse
                    import os
                    import json
                    from datetime import datetime
                    
                    from colorama import init, Fore, Style
                    
                    from crypto_utils import (
                        log_error,           # Does nothing
                        create_key_from_password,
                        encrypt_data,
                        decrypt_data,
                        parse_data_key
                    )
                    
                    # Initialize colorama for cross-platform colored output
                    init(autoreset=True)
                    
                    def print_intro():
                        """
                        Print an intro banner with a skull to set the mood.
                        """
                        # Notice how we've escaped or replaced the extra `"""` to avoid breaking the string
                        skull_art = """
                               .... NO ESCAPE ....
                                    uuuuuuu
                                uu$$$$$$$$$$$uu
                             uu$$$$$$$$$$$$$$$$$uu
                            u$$$$$$$$$$$$$$$$$$$$$u
                            u$$$$$$$$$$$$$$$$$$$$$u
                            u$$$$$$"   "$$$"   "$$$$$u
                            "$$$$"      u$u       $$$$"
                             $$$u       u$u       u$$$
                             $$$u      u$$$u      u$$$
                              "$$$$uu$$$   $$$uu$$$$"
                               "$$$$$$$"   "$$$$$$$"
                                 u$$$$$$$u$$$$$$$u
                                  u$"$"$"$"$"$"$u
                       uuu        $$u$ $ $ $ $u$$       uuu
                      u$$$$        $$$$$u$u$u$$$       u$$$$
                       $$$$$uu      "$$$$$$$$$"     uu$$$$$$
                     u$$$$$$$$$$$uu    \"\"\"\"\"    uuuu$$$$$$$$$$
                     $$$$\"\"\"$$$$$$$$$$uuu   uu$$$$$$$$$\"\"\"$$$\"
                       \"\"\"      \"\"$$$$$$$$$$$uu \"\"$\"\"\"
                                uuuu \"\"$$$$$$$$$$uuu
                       u$$$uuu$$$$$$$$$uu \"\"$$$$$$$$$$$uuu$$$
                       $$$$$$$$$$\"\"\"\"           \"\"$$$$$$$$$$$\"
                        \"$$$$$\"                      \"\"$$$$\"\"
                          $$$\"                         $$$$\"
                        """
                        
                        print(Fore.RED + skull_art + Style.RESET_ALL)
                        print(Fore.YELLOW + "Welcome to the AES Encryption/Decryption Tool" + Style.RESET_ALL)
                        print(Fore.CYAN + "Supported modes: ECB, CBC, CTR, GCM, CCM" + Style.RESET_ALL)
                        print(Fore.MAGENTA + "Supported key sizes: 128, 192, 256, 512 (512 => truncated to 256)" + Style.RESET_ALL)
                        print(Fore.BLUE + "PKCS#7 padding applied for ECB/CBC. IV/nonce sizes set to fix errors." + Style.RESET_ALL)
                    
                    
                    def main():
                        parser = argparse.ArgumentParser(description="AES tool supporting multiple modes and key sizes, with error fixes.")
                        parser.add_argument("mode", choices=["encrypt", "decrypt"], help="Mode: encrypt or decrypt")
                        parser.add_argument("--password", "-p", required=True, help="Password to derive key")
                        parser.add_argument("--input", "-i", required=True, help="Input file to encrypt/decrypt")
                        parser.add_argument("--output", "-o", help="Output file to write result (auto-generated if omitted)")
                        parser.add_argument("--salt-file", "-s", default="salt.bin", help="File to read/store salt")
                        parser.add_argument("--data-key-file", "-d", help="Optional base64-encoded data key to XOR with derived key")
                        parser.add_argument("--aes-mode", default="cbc", help="AES mode (ecb, cbc, ctr, gcm, ccm). Default = cbc")
                        parser.add_argument("--key-size", type=int, default=128, help="AES key size in bits (128,192,256,512)")
                    
                        args = parser.parse_args()
                    
                        # Print introduction
                        print_intro()
                    
                        # 1. Load/generate salt
                        try:
                            if os.path.exists(args.salt_file):
                                with open(args.salt_file, 'rb') as f:
                                    salt = f.read()
                            else:
                                salt = os.urandom(16)
                                with open(args.salt_file, 'wb') as f:
                                    f.write(salt)
                        except Exception as e:
                            print(Fore.RED + f"Error handling salt file: {e}" + Style.RESET_ALL)
                            raise SystemExit(1)
                    
                        # 2. Create derived key from password (with requested key size)
                        try:
                            derived_key = create_key_from_password(args.password, salt, key_size=args.key_size)
                        except Exception as e:
                            print(Fore.RED + f"Could not create derived key: {e}" + Style.RESET_ALL)
                            raise SystemExit(1)
                    
                        # 3. Optionally parse data key file and XOR
                        if args.data_key_file:
                            try:
                                extra_key = parse_data_key(args.data_key_file)
                                # XOR them for demonstration (not recommended in production)
                                derived_key = bytes(a ^ b for (a, b) in zip(derived_key, extra_key[:len(derived_key)]))
                            except Exception as e:
                                print(Fore.RED + f"Could not parse or combine data key: {e}" + Style.RESET_ALL)
                                raise SystemExit(1)
                    
                        # 4. Read input data
                        try:
                            with open(args.input, 'rb') as f:
                                data = f.read()
                        except Exception as e:
                            print(Fore.RED + f"Could not read input file: {e}" + Style.RESET_ALL)
                            raise SystemExit(1)
                    
                        # If user doesn't provide an output file, generate one
                        if not args.output:
                            timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
                            if args.mode == "encrypt":
                                args.output = f"encrypt_{args.aes_mode}_{timestamp_str}.json"
                            else:
                                args.output = f"decrypt_{args.aes_mode}_{timestamp_str}.dec"
                    
                        # 5. Encrypt or decrypt
                        if args.mode == "encrypt":
                            try:
                                result = encrypt_data(derived_key, data, aes_mode=args.aes_mode)
                                with open(args.output, 'w') as f:
                                    json.dump(result, f, indent=2)
                                print(Fore.GREEN + f"File encrypted successfully: {args.output}" + Style.RESET_ALL)
                            except Exception as e:
                                print(Fore.RED + f"Encryption failed: {e}" + Style.RESET_ALL)
                                raise SystemExit(1)
                        else:  # decrypt
                            try:
                                with open(args.input, 'r') as f:
                                    data_dict = json.load(f)
                                decrypted = decrypt_data(derived_key, data_dict)
                                with open(args.output, 'wb') as f:
                                    f.write(decrypted)
                                print(Fore.GREEN + f"File decrypted successfully: {args.output}" + Style.RESET_ALL)
                            except Exception as e:
                                print(Fore.RED + f"Decryption failed: {e}" + Style.RESET_ALL)
                                raise SystemExit(1)
                    
                    
                    if __name__ == "__main__":
                        main()

            </code></pre>
       
                <h4> Requirements.txt </h4>
                    <pre><code class="language-txt"> 
                    
                        cryptography==44.0.0
                        colorama==0.4.6
                    
            </code></pre>
       

                <h5> Requirements.txt </h5>
   
                    <pre><code class="language-docker"> 
                        # Use a lightweight Python base image 3.14.0a3-bullseye
                        FROM python:3.12-slim
                        
                        # Set a working directory
                        WORKDIR /app
                        
                        # Copy requirements and install dependencies
                        COPY requirements.txt .
                        RUN pip install --no-cache-dir -r requirements.txt
                        
                        # Copy our source code into the image
                        COPY src/crypto_utils.py src/main.py ./
                        
                        # When the container starts, by default it will show the help text for main.py
                        CMD ["python", "src/main.py", "--help"]
   
            </code></pre>

            
        </section>
                                <!-- Highlight.js Script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    </main>
    <footer>
        <p>© 2024 ebholoijieh0 | GitHub Pages</p>
    </footer>
</body>
</html>
