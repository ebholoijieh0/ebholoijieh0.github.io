<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CVE-2024 - Example 1</title>
    <link rel="stylesheet" href="../css/style.css" />
</head>
<body>
    <header>
        <h1>CVE-2024 - Example 1</h1>
        <a href="../index.html">Back to Main Page</a>
    </header>
    <main>
        <section>
            <h2>Tool Overview</h2>
            <p>This tool shows checksum verifier and generator capability </p>
            <h3> checksum</h3>
            <pre>
<code>
import sys
import hashlib
import argparse
import os
import logging
from datetime import datetime

# ANSI color codes
RESET = "\033[0m"
BOLD = "\033[1m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
GREEN = "\033[92m"
RED = "\033[91m"

# Set up logging
class ColoredFormatter(logging.Formatter):
    """A custom formatter to add colors and formatting to console logs based on log level."""
    level_colors = {
        logging.DEBUG: CYAN,
        logging.INFO: GREEN,
        logging.WARNING: YELLOW,
        logging.ERROR: RED,
        logging.CRITICAL: RED
    }

    def format(self, record):
        # Add color based on level
        # Create a time string using formatTime
        asctime = self.formatTime(record, self.datefmt)
        log_color = self.level_colors.get(record.levelno, RESET)

        #log_color = self.level_colors.get(record.levelno, RESET)
                # record.getMessage() will return the message after any args substitution
        msg = record.getMessage()  # Correctly get the message        
        s = f"{log_color}{asctime} - {record.levelname} - {msg}{RESET}"
        return s

# Create a logger
logger = logging.getLogger("ChecksumTool")
logger.setLevel(logging.DEBUG)  # Log all levels

# Console handler with color formatter
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(logging.DEBUG)
console_formatter = ColoredFormatter("%(asctime)s - %(levelname)s - %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
console_handler.setFormatter(console_formatter)

# File handler (no colors)
file_handler = logging.FileHandler("checksum_tool.log", mode='a')
file_handler.setLevel(logging.DEBUG)
file_formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
file_handler.setFormatter(file_formatter)

# Add handlers to logger
logger.addHandler(console_handler)
logger.addHandler(file_handler)

def compute_checksum(file_path, algorithm='sha256'):
    """Compute the specified checksum for a given file."""
    if not hasattr(hashlib, algorithm):
        logger.error(f"Unsupported algorithm: {algorithm}")
        raise ValueError(f"Unsupported algorithm: {algorithm}")

    hash_func = getattr(hashlib, algorithm)()
    logger.debug(f"Computing {algorithm} checksum for file: {file_path}")

    with open(file_path, 'rb') as f:
        for chunk in iter(lambda: f.read(8192), b''):
            hash_func.update(chunk)
    return hash_func.hexdigest()

def find_file_in_current_directory(filename):
    """Search for a file by name in the current directory and its subdirectories."""
    matches = []
    logger.debug(f"Searching for file '{filename}' in current directory.")
    for root, dirs, files in os.walk('.'):
        if filename in files:
            matches.append(os.path.join(root, filename))
    logger.debug(f"Found {len(matches)} matches for '{filename}'.")
    return matches

def get_file_path(prompt):
    """Prompt the user for a file path or filename. If just a filename is given, try to find it."""
    user_input = input(CYAN + prompt + RESET).strip()
    logger.info(f"User entered: {user_input}")

    if os.path.isfile(user_input):
        logger.info(f"User input is a direct file path: {user_input}")
        return user_input
    else:
        matches = find_file_in_current_directory(user_input)
        if len(matches) == 1:
            logger.info(f"One match found: {matches[0]}")
            return matches[0]
        elif len(matches) > 1:
            logger.warning("Multiple files found with that name.")
            for i, match in enumerate(matches, start=1):
                logger.info(f"{i}. {match}")
            choice = input(CYAN + "Enter the number of the file you want to use: " + RESET).strip()
            logger.info(f"User chose file number: {choice}")
            if choice.isdigit():
                choice_idx = int(choice) - 1
                if 0 <= choice_idx < len(matches):
                    logger.info(f"User selected: {matches[choice_idx]}")
                    return matches[choice_idx]
            logger.error("Invalid choice. Exiting.")
            sys.exit(1)
        else:
            logger.error(f"No file found named '{user_input}' in the current directory.")
            sys.exit(1)

def generate_checksum():
    """Interactively generate a checksum for a file and save it to a timestamped file."""
    logger.info("User chose to generate a checksum.")
    file_path = get_file_path("Enter the path or filename of the file to generate a checksum for: ")
    chosen_algorithm = input(CYAN + "Enter the checksum algorithm (or press Enter for sha256): " + RESET).strip()
    logger.info(f"User chose algorithm: {chosen_algorithm if chosen_algorithm else 'sha256'}")
    if not chosen_algorithm:
        chosen_algorithm = 'sha256'
    
    try:
        checksum_value = compute_checksum(file_path, chosen_algorithm)
    except ValueError as e:
        logger.error(str(e))
        sys.exit(1)

    base_name = os.path.basename(file_path)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filename = f"{base_name}_{chosen_algorithm}_{timestamp}.checksum"
    output_path = os.path.join('.', output_filename)

    with open(output_path, 'w') as out_f:
        out_f.write(checksum_value + '\n')

    logger.info(f"Checksum generated successfully for '{file_path}'.")
    logger.info(f"Checksum ({chosen_algorithm}) written to: {output_path}")

def verify_checksum(args):
    logger.info("Starting checksum verification process.")
    if not os.path.isfile(args.file):
        logger.error(f"The file '{args.file}' does not exist or is not a file.")
        sys.exit(1)

    if not os.path.isfile(args.checksum_file):
        logger.error(f"The checksum file '{args.checksum_file}' does not exist or is not a file.")
        sys.exit(1)

    with open(args.checksum_file, 'r') as cf:
        expected_checksum = cf.read().strip()

    try:
        actual_checksum = compute_checksum(args.file, args.algorithm)
    except ValueError as e:
        logger.error(str(e))
        sys.exit(1)

    if actual_checksum == expected_checksum:
        logger.info(f"✅ Success! The file checksum matches the expected {args.algorithm} hash.")
    else:
        logger.error("❌ Checksum mismatch!")
        logger.error(f"Expected {args.algorithm}: {expected_checksum}")
        logger.error(f"Actual   {args.algorithm}: {actual_checksum}")

def main():
    parser = argparse.ArgumentParser(
        description="A versatile tool to verify or generate file checksums!",
        usage="python verify_checksum.py [options]"
    )
    parser.add_argument(
        '-f', '--file',
        help="Path or filename of the file whose checksum you want to verify."
    )
    parser.add_argument(
        '-c', '--checksum-file',
        help="Path or filename of the file containing the expected checksum."
    )
    parser.add_argument(
        '-a', '--algorithm',
        default='sha256',
        help="Checksum algorithm to use (default: sha256). Options include sha256, sha512, md5, etc."
    )

    args = parser.parse_args()

    if len(sys.argv) == 1:
        logger.info("No command-line arguments provided. Entering interactive mode...")
        logger.info("============================================================")
        logger.info("              Welcome to the Checksum Tool!")
        logger.info("============================================================")
        logger.info("This tool can verify the integrity of your files by comparing")
        logger.info("their computed checksums against expected values, or it can")
        logger.info("generate a checksum file for a given file.")
        logger.info("")
        logger.info("You can use this tool in three ways:")
        logger.info("")
        logger.info("1. Command-line verification (non-interactive)")
        logger.info("   Example: python verifygenerate_checksum.py -f /path/to/file -c /path/to/checksumfile -a sha256")
        logger.info("")
        logger.info("2. Interactive verification")
        logger.info("   Run: python verifygenerate_checksum.py (no args), choose verification, follow prompts.")
        logger.info("")
        logger.info("3. Interactive checksum generation")
        logger.info("   Run: python verifygenerate_checksum.py (no args), choose generation, follow prompts.")
        logger.info("")
        logger.info("If you provide just a filename instead of a full path, the tool")
        logger.info("will search the current directory and subdirectories.")
        logger.info("------------------------------------------------------------")

        mode = input(CYAN + "Do you want to (v)erify a checksum or (g)enerate a checksum? [v/g]: " + RESET).strip().lower()
        logger.info(f"User selected mode: {mode}")
        if mode == 'v':
            args.file = get_file_path("Enter the path or filename of the file you want to verify: ")
            args.checksum_file = get_file_path("Enter the path or filename of the file containing the expected checksum: ")
            chosen_algorithm = input(CYAN + "Enter the checksum algorithm (or press Enter for sha256): " + RESET).strip()
            logger.info(f"User chose algorithm: {chosen_algorithm if chosen_algorithm else 'sha256'}")
            if chosen_algorithm:
                args.algorithm = chosen_algorithm
            verify_checksum(args)
        elif mode == 'g':
            generate_checksum()
        else:
            logger.error("Invalid choice. Exiting.")
            sys.exit(1)
    else:
        logger.info("Command-line arguments provided. Attempting verification mode.")
        if not args.file:
            args.file = get_file_path("Enter the path or filename of the file you want to verify: ")
        else:
            if not os.path.exists(args.file):
                matches = find_file_in_current_directory(os.path.basename(args.file))
                if len(matches) == 1:
                    args.file = matches[0]
                elif len(matches) > 1:
                    logger.warning("Multiple files found with that name.")
                    for i, match in enumerate(matches, start=1):
                        logger.info(f"{i}. {match}")
                    choice = input(CYAN + "Enter the number of the file you want to use: " + RESET).strip()
                    logger.info(f"User chose file number: {choice}")
                    if choice.isdigit():
                        choice_idx = int(choice) - 1
                        if 0 <= choice_idx < len(matches):
                            args.file = matches[choice_idx]
                        else:
                            logger.error("Invalid choice. Exiting.")
                            sys.exit(1)
                    else:
                        logger.error("Invalid choice. Exiting.")
                        sys.exit(1)
                else:
                    logger.error(f"File '{args.file}' not found.")
                    sys.exit(1)

        if not args.checksum_file:
            args.checksum_file = get_file_path("Enter the path or filename of the file containing the expected checksum: ")
        else:
            if not os.path.exists(args.checksum_file):
                matches = find_file_in_current_directory(os.path.basename(args.checksum_file))
                if len(matches) == 1:
                    args.checksum_file = matches[0]
                elif len(matches) > 1:
                    logger.warning("Multiple checksum files found with that name.")
                    for i, match in enumerate(matches, start=1):
                        logger.info(f"{i}. {match}")
                    choice = input(CYAN + "Enter the number of the checksum file you want to use: " + RESET).strip()
                    logger.info(f"User chose checksum file number: {choice}")
                    if choice.isdigit():
                        choice_idx = int(choice) - 1
                        if 0 <= choice_idx < len(matches):
                            args.checksum_file = matches[choice_idx]
                        else:
                            logger.error("Invalid choice. Exiting.")
                            sys.exit(1)
                    else:
                        logger.error("Invalid choice. Exiting.")
                        sys.exit(1)
                else:
                    logger.error(f"Checksum file '{args.checksum_file}' not found.")
                    sys.exit(1)

        verify_checksum(args)

if __name__ == "__main__":
    main()
</code>
            </pre>
        </section>
    </main>
    <footer>
        <p>© 2024 ebholoijieh0 | GitHub Pages</p>
    </footer>
</body>
</html>
